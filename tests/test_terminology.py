"""
Regression test: enforce AI -> LLM terminology across all templates.

Per the Session 10 terminology decision:
- "AI" is replaced with "language model" / "LLM" in all project-controlled text
- "AI" is kept ONLY for: academic field names (AI Literacy), external source
  titles, external product names (Vertex AI, Google AI Studio), and code
  identifiers (CSS classes, HTML IDs, JS variable names)

This test globs all templates and flags any non-whitelisted \bAI\b occurrence.
"""

import os
import re

TEMPLATES_DIR = os.path.join(os.path.dirname(__file__), "..", "templates")

# Patterns that are allowed to contain "AI" (external names, code identifiers, etc.)
ALLOWED_PATTERNS = [
    # External source titles (academic / institutional)
    r"AI Competency Framework",
    r"AI and the Future",
    r"AI Literacy",
    r"Explainable AI in Education",
    # External product names
    r"Google AI Studio",
    r"Vertex AI",
    # Code identifiers (CSS classes, HTML attributes, JS variables)
    r'class="ai-',
    r"ai-notice",
    r"ai-draft",
    r"#understanding-ai",
    r'"ai-literacy"',
    r"ai_literacy",
    r"// ---.*AI",
    r"aistudio\.google\.com",
    # URL fragments containing "ai"
    r"ai-report",
]

# Compile a single regex that matches any allowed pattern
_ALLOWED_RE = re.compile("|".join(ALLOWED_PATTERNS), re.IGNORECASE)

# The regex to find bare "AI" as a standalone word
_AI_RE = re.compile(r"\bAI\b")


def _collect_template_files():
    """Collect all .html template files recursively."""
    result = []
    for root, _dirs, files in os.walk(TEMPLATES_DIR):
        for fname in files:
            if fname.endswith(".html"):
                rel = os.path.relpath(os.path.join(root, fname), TEMPLATES_DIR)
                result.append(rel)
    return sorted(result)


def _is_allowed(line):
    """Check if every AI occurrence on this line is covered by an allowed pattern."""
    # Remove all allowed pattern matches from the line, then check if AI remains
    cleaned = _ALLOWED_RE.sub("", line)
    return not _AI_RE.search(cleaned)


class TestTerminologyCompliance:
    """Ensure no non-whitelisted 'AI' appears in user-facing templates."""

    def test_no_bare_ai_in_templates(self):
        """All template files use 'LLM' or 'language model' instead of bare 'AI'."""
        violations = []

        for rel_path in _collect_template_files():
            full_path = os.path.join(TEMPLATES_DIR, rel_path)
            with open(full_path, encoding="utf-8") as f:
                for lineno, line in enumerate(f, 1):
                    if _AI_RE.search(line) and not _is_allowed(line):
                        violations.append(
                            f"  {rel_path}:{lineno}: {line.rstrip()}"
                        )

        assert violations == [], (
            "Found non-whitelisted 'AI' in templates. "
            "Use 'LLM' or 'language model' instead.\n"
            + "\n".join(violations)
        )

    def test_template_files_exist(self):
        """Sanity check: templates directory exists and has files."""
        files = _collect_template_files()
        assert len(files) > 10, f"Expected >10 template files, found {len(files)}"

    def test_whitelist_covers_known_exceptions(self):
        """Verify the whitelist handles known allowed patterns."""
        allowed_lines = [
            "UNESCO (2024). AI Competency Framework for Teachers",
            "Digital Promise (2024). AI Literacy Framework",
            "<strong>Google Vertex AI</strong>",
            "Google AI Studio",
            'class="ai-notice"',
            'href="#understanding-ai"',
            'data-accordion="ai-literacy"',
            "// --- AI Notice Dismiss (sessionStorage) ---",
            "Vertex AI API",
            "Khosravi et al. (2022). Explainable AI in Education",
        ]
        for line in allowed_lines:
            assert _is_allowed(line), f"Whitelist should allow: {line}"

    def test_whitelist_catches_violations(self):
        """Verify the whitelist correctly catches non-allowed AI usage."""
        bad_lines = [
            "AI-Generated Content",
            "This quiz was generated by AI.",
            "Set up an AI provider",
            "AI-powered teaching assistant",
            "AI creates assessments",
        ]
        for line in bad_lines:
            assert not _is_allowed(line), f"Should be flagged as violation: {line}"
